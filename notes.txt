To shrink test case we need to be able to check whether a shrunken
value could have been generated by the original generator. Which can
be arbitrarily hard if the generator contains, say, a map. for
instance:

 generator[Int].map(_ * 2)

only generates even ints. But a general purpose shrinker for ints
might try subtracting 1 from the original value, producing a value
that the generator would never have generated.

One case one could catch this (and which scalacheck seems to do) is
generators created by adding a filter: save the filter and then apply
it to values produced by the shrinker. I assume this is why in
scalacheck there are some seemingly redundant calls to suchThat on
some of the generators--those calls install a filter which will then
be used by the shrinkers. But since you can also change the range of
possible generated values with a map or flatMap, the shrinking
mechanism is not really 100% correct. Perhaps the thing to do is to
specify a generator as both a generation function and a shrinking
function.

So to be fully general, the shrinker and the generator need to be
somewhat tightly coupled. To be fully correct, the shrinker needs to
be a function from the set of values possibly produced by the
generator only to other such values. One way to arrange that is to
make sure that

Another possibly useful thing would be to instead of shrinking the
value, to shrink the generator to something that produces values in a
smaller space but that still includes the failing value. For instance,
if our original generator generated totally arbitrary Ints and our
test failed at value N, then we could shrink that to a generator that
only generated ints that are near N or multiples of N or other subsets
of Ints. This could actually serve to find not only a minimal test
case (which doesn't actually make sense for an Int value) but to
possibly find where in the number line the problem lies. I.e. if all
values < M are okay and M < N we're more interested in M than N.

For tuple generators, the same basic trick applies, for an N-tuple,
use N new generators each with one of the element generators shrunk.

But in more general cases where the space is multidimensional (e.g. a
generator of tuples)

To shrink a value produced by a mapped generator ... we're kind of
screwed. Only way to reliably shrink the output of such a generator is
to construct a compatible shrinker. Which can certainly be done for
the arbitrary generators since all we care is that it's an instance of
the right type. And we can handle the case where we have a generator
that we know how to shrink and we add a filter.

Arbitrary generator: arbitrary shrinker
Filtered generator: arbitrary shrinker + same filter
Mapped generator: no good answer.
FlatMapped generator: if we assume it's a composed
